# 正则表达式的使用（二）

## 零宽断言

接上节内容，首先，让我们再次记忆一下这个表格：

分类 | <font color="#DC143C">常用分组语法</font> | 说明
----|---|----
捕获 |`(exp)`	| 匹配exp,并捕获文本到自动命名的组里
（同上）|`(?<name>exp)`	| 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
（同上） |`(?:exp)`	| 匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言	|(?=exp) | 	匹配exp前面的位置
 （同上） | (?<=exp)	|匹配exp后面的位置
 （同上） |(?!exp)	|匹配后面跟的不是exp的位置
 （同上） |(?<!exp)	|匹配前面不是exp的位置
注释|	(?#comment)	|这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

## 什么是零宽断言？
如上表中的一些分组语法，它们像\b,^,$那样**用于指定一个位置**，这个位置**应该满足一定的条件(即断言)**，因此它们也被称为**零宽断言**。

(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。

(?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。

## 负向零宽断言


\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。

零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。

一个更复杂的例子：(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。
(?<=<(\w+)>).*(?=<\/\1>)，这个表达式最能表现零宽断言的真正用途。

## 注释

小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：

 代码| 注释     
----- | ------
(?<=   | # 断言要匹配的文本的前缀
      <(\w+)> |  # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )      | # 前缀结束
      .*     | # 匹配任意文本
      (?=    | # 断言要匹配的文本的后缀
      <\/\1> | # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )     |  # 后缀结束
      
      
## 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。      

为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。



